<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<title>A trip through the Graphics Pipeline 2011</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child{border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active,#footnotes .footnote a:first-of-type:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_a_trip_through_the_graphics_pipeline_2011">A trip through the Graphics Pipeline 2011</a>
<ul class="sectlevel2">
<li><a href="#_bookmarks">Bookmarks</a></li>
<li><a href="#_part_1_introduction_the_software_stack">Part 1: Introduction; the Software stack.</a>
<ul class="sectlevel3">
<li><a href="#_the_application">The application</a></li>
<li><a href="#_the_api_runtime">The API runtime</a></li>
<li><a href="#_the_user_mode_graphics_driver_or_umd">The user-mode graphics driver (or UMD)</a></li>
<li><a href="#_enter_the_scheduler">Enter the scheduler.</a></li>
<li><a href="#_the_kernel_mode_driver_kmd">The kernel-mode driver (KMD)</a></li>
<li><a href="#_small_aside_opengl">Small aside: OpenGL</a></li>
</ul>
</li>
<li><a href="#_part_2_gpu_memory_architecture_and_the_command_processor">Part 2: GPU memory architecture and the Command Processor.</a>
<ul class="sectlevel3">
<li><a href="#_not_so_fast">Not so fast.</a></li>
<li><a href="#_the_memory_subsystem">The memory subsystem</a></li>
<li><a href="#_the_pcie_host_interface">The PCIe host interface</a></li>
<li><a href="#_some_final_memory_bits_and_pieces">Some final memory bits and pieces</a></li>
<li><a href="#_at_long_last_the_command_processor">At long last, the command processor!</a></li>
<li><a href="#_synchronization">Synchronization</a></li>
</ul>
</li>
<li><a href="#_part_3_3d_pipeline_overview_vertex_processing">Part 3: 3D pipeline overview, vertex processing.</a>
<ul class="sectlevel3">
<li><a href="#_have_some_alphabet_soup">Have some Alphabet Soup!</a></li>
<li><a href="#_input_assembler_stage">Input Assembler stage</a></li>
<li><a href="#_vertex_caching_and_shading">Vertex Caching and Shading</a></li>
<li><a href="#_shader_unit_internals">Shader Unit internals</a></li>
</ul>
</li>
<li><a href="#_part_4_texture_samplers">Part 4: Texture samplers.</a>
<ul class="sectlevel3">
<li><a href="#_texture_state">Texture state</a></li>
<li><a href="#_but_who_asks_for_a_single_texture_sample">But who asks for a single texture sample?</a></li>
<li><a href="#_and_once_the_texture_coordinates_arrive">And once the texture coordinates arrive…</a></li>
<li><a href="#_texture_cache">Texture cache</a></li>
<li><a href="#_filtering">Filtering</a></li>
<li><a href="#_texture_returns">Texture returns</a></li>
<li><a href="#_the_usual_post_script">The usual post-script</a></li>
</ul>
</li>
<li><a href="#_part_5_primitive_assembly_clipcull_projection_and_viewport_transform">Part 5: Primitive Assembly, Clip/Cull, Projection, and Viewport transform.</a>
<ul class="sectlevel3">
<li><a href="#_primitive_assembly">Primitive Assembly</a></li>
<li><a href="#_viewport_culling_and_clipping">Viewport culling and clipping</a></li>
<li><a href="#_guard_band_clipping">Guard-band clipping</a></li>
<li><a href="#_aside_getting_clipping_right">Aside: Getting clipping right</a></li>
<li><a href="#_those_pesky_near_and_far_planes">Those pesky near and far planes</a></li>
<li><a href="#_projection_and_viewport_transform">Projection and viewport transform</a></li>
<li><a href="#_back_face_and_other_triangle_culling">Back-face and other triangle culling</a></li>
<li><a href="#_final_remarks">Final remarks</a></li>
</ul>
</li>
<li><a href="#_part_6_triangle_rasterization_and_setup">Part 6: (Triangle) rasterization and setup.</a>
<ul class="sectlevel3">
<li><a href="#_how_not_to_render_a_triangle">How <em>not</em> to render a triangle</a></li>
<li><a href="#_a_better_way">A better way</a></li>
<li><a href="#_what_we_need_around_here_is_more_hierarchy">What we need around here is more hierarchy</a></li>
<li><a href="#_so_what_does_triangle_setup_do">So what does triangle setup do?</a></li>
<li><a href="#_other_rasterization_issues_and_pixel_output">Other rasterization issues and pixel output</a></li>
<li><a href="#_caveats">Caveats</a></li>
</ul>
</li>
<li><a href="#_part_7_zstencil_processing_3_different_ways">Part 7: Z/Stencil processing, 3 different ways.</a>
<ul class="sectlevel3">
<li><a href="#_interpolated_values">Interpolated values</a></li>
<li><a href="#_early_zstencil">Early Z/Stencil</a></li>
<li><a href="#_zstencil_writes_the_full_truth">Z/stencil writes: the full truth</a></li>
<li><a href="#_hierarchical_zstencil">Hierarchical Z/Stencil</a></li>
<li><a href="#_revenge_of_the_api_order">Revenge of the API order</a></li>
<li><a href="#_memory_bandwidth_and_z_compression">Memory bandwidth and Z compression</a></li>
</ul>
</li>
<li><a href="#_part_8_pixel_processing_fork_phase">Part 8: Pixel processing – “fork phase”.</a>
<ul class="sectlevel3">
<li><a href="#_going_wide_during_rasterization">Going wide during rasterization</a></li>
<li><a href="#_you_need_to_go_wider">You need to go wider!</a></li>
<li><a href="#_attribute_interpolation">Attribute interpolation</a></li>
<li><a href="#_centroid_interpolation_is_tricky">“Centroid” interpolation is tricky</a></li>
<li><a href="#_the_actual_shader_body">The actual shader body</a></li>
</ul>
</li>
<li><a href="#_part_9_pixel_processing_join_phase">Part 9: Pixel processing – “join phase”.</a>
<ul class="sectlevel3">
<li><a href="#_merging_pixels_again_blend_and_late_z">Merging pixels again: blend and late Z</a></li>
<li><a href="#_meet_the_rops">Meet the ROPs</a></li>
<li><a href="#_memory_bandwidth_redux_dram_pages">Memory bandwidth redux: DRAM pages</a></li>
<li><a href="#_depth_buffer_and_color_buffer_compression">Depth buffer and color buffer compression</a></li>
<li><a href="#_1_blend_in_pixel_shader">1. Blend in Pixel Shader</a></li>
<li><a href="#_2_blend_shaders">2. “Blend Shaders”</a></li>
</ul>
</li>
<li><a href="#_part_10_geometry_shaders">Part 10: Geometry Shaders.</a>
<ul class="sectlevel3">
<li><a href="#_theres_multiple_pipelines_anatomy_of_a_pipeline_stage">There’s multiple pipelines / anatomy of a pipeline stage</a></li>
<li><a href="#_the_shape_of_tris_to_shade">The Shape of Tris to Shade</a></li>
<li><a href="#_gs_output_no_rose_garden_over_here_either">GS output: no rose garden over here, either</a></li>
<li><a href="#_api_order_again">API order again</a></li>
<li><a href="#_vpai_and_rtai">VPAI and RTAI</a></li>
<li><a href="#_summary_so_far">Summary so far</a></li>
<li><a href="#_bonus_gs_instancing">Bonus: GS Instancing</a></li>
</ul>
</li>
<li><a href="#_part_11_stream_out">Part 11: Stream-Out.</a>
<ul class="sectlevel3">
<li><a href="#_vertex_shader_stream_out_i_e_so_with_null_gs">Vertex Shader Stream-Out (i.e. SO with NULL GS)</a></li>
<li><a href="#_geometry_shader_so_multiple_streams">Geometry Shader SO: Multiple streams</a></li>
<li><a href="#_tracking_output_size">Tracking output size</a></li>
</ul>
</li>
<li><a href="#_part_12_tessellation">Part 12: Tessellation.</a>
<ul class="sectlevel3">
<li><a href="#_tessellation_not_quite_like_youd_expect">Tessellation – not quite like you’d expect</a></li>
<li><a href="#_making_ends_meet">Making ends meet</a></li>
<li><a href="#_fractional_tessellation_factors_and_overall_pipeline_flow">Fractional tessellation factors and overall pipeline flow</a></li>
<li><a href="#_hull_shader_execution">Hull Shader execution</a></li>
<li><a href="#_domain_shaders">Domain Shaders</a></li>
<li><a href="#_final_remarks_2">Final remarks</a></li>
</ul>
</li>
<li><a href="#_part_13_compute_shaders">Part 13: Compute Shaders.</a>
<ul class="sectlevel3">
<li><a href="#_execution_environment">Execution environment</a></li>
<li><a href="#_thread_groups">Thread Groups</a></li>
<li><a href="#_unordered_access_views">Unordered Access Views</a></li>
<li><a href="#_atomics">Atomics</a></li>
<li><a href="#_structured_buffers_and_appendconsume_buffers">Structured buffers and append/consume buffers</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_a_trip_through_the_graphics_pipeline_2011">A trip through the Graphics Pipeline 2011</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is a shorter version of the following series of articles by by Fabian “<em>ryg</em>” Giesen: <a href="https://fgiesen.wordpress.com/2011/07/09/a-trip-through-the-graphics-pipeline-2011-index/" class="bare">https://fgiesen.wordpress.com/2011/07/09/a-trip-through-the-graphics-pipeline-2011-index/</a></p>
</div>
<div class="sect2">
<h3 id="_bookmarks">Bookmarks</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#glsl-compilation">GLSL compilation</a></p>
</li>
<li>
<p><a href="#dma-engine">DMA engine</a></p>
</li>
<li>
<p><a href="#fences">Fences</a> (D3D11, Vulkan)</p>
</li>
<li>
<p><a href="#semaphores">Semaphores</a> (Vulkan)</p>
</li>
<li>
<p><a href="#gradients">Gradients</a></p>
</li>
<li>
<p><a href="#context_switch">Context Switch</a></p>
</li>
<li>
<p><a href="#mip_mapping">MIP Mapping</a></p>
</li>
<li>
<p><a href="#ndc">Normalized Device Coordinate</a></p>
</li>
<li>
<p><a href="#slivers">Slivers Triangles</a></p>
</li>
<li>
<p><a href="#scissor_test">Scissor Test</a></p>
</li>
<li>
<p><a href="#msaa">Multisample Anti-Aliasing </a></p>
</li>
<li>
<p><a href="#mobile_tiled">Mobile Tiled Renderers and Binning</a></p>
</li>
<li>
<p><a href="#early_z">Early Z-test</a></p>
</li>
<li>
<p><a href="#fast_z_clear">Fast Z Clear</a></p>
</li>
<li>
<p><a href="#nvidia_warp">Nvidia Warp</a></p>
</li>
<li>
<p><a href="#helper_pixels">Helper pixels</a> (OpenGL: <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/gl_HelperInvocation.xhtml">gl_HelperInvocation</a>)</p>
</li>
<li>
<p><a href="#context_switch2">Context Switch and Occupancy</a></p>
</li>
<li>
<p><a href="#lockstep_execution">Lockstep Execution</a></p>
</li>
<li>
<p><a href="#discard">Discard</a></p>
</li>
<li>
<p><a href="#fast_color_clear">Fast Color Clear</a></p>
</li>
<li>
<p><a href="#cs_threads">Compute Shader Threads</a> (Warps and Wavefronts, context switch, lockstep execution)</p>
</li>
<li>
<p><a href="#barriers">Barriers</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_part_1_introduction_the_software_stack">Part 1: Introduction; the Software stack.</h3>
<div class="paragraph">
<p><a href="https://fgiesen.wordpress.com/2011/07/01/a-trip-through-the-graphics-pipeline-2011-part-1/" class="bare">https://fgiesen.wordpress.com/2011/07/01/a-trip-through-the-graphics-pipeline-2011-part-1/</a></p>
</div>
<div class="sect3">
<h4 id="_the_application">The application</h4>
<div class="paragraph">
<p>This is your code.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_api_runtime">The API runtime</h4>
<div class="paragraph">
<p>The API runtime keeps track of the current state your app has set, validates parameters and does other error and consistency checking, manages user-visible resources, may or may not validate shader code and shader linkage.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_user_mode_graphics_driver_or_umd">The user-mode graphics driver (or UMD)</h4>
<div class="ulist">
<ul>
<li>
<p>It’s running in the same context and address space as your app (and the API runtime) and has no elevated privileges whatsoever. It implements a lower-level API (the DDI) that is called by D3D.</p>
</li>
<li>
<p>Some of the API states may actually end up being compiled into the shader.</p>
</li>
<li>
<p>A lot of the creation/compilation work is deferred by the driver and only executed when it’s actually necessary. If you want to make sure something is actually created (as opposed to just having memory reserved), you need to issue a dummy draw call that uses it to “warm it up”.</p>
</li>
<li>
<p>It suballocates some larger memory blocks it gets from the KMD; actually mapping and unmapping pages is a kernel-mode privilege and can’t be done by the UMD.</p>
</li>
<li>
<p>It can do things like swizzling textures and schedule transfers between system memory and (mapped) video memory and the like. It can also write command buffers.</p>
</li>
<li>
<p>Drivers will try to put as much of the actual processing into the UMD as possible; the UMD is user-mode code, so anything that runs in it doesn’t need any costly kernel-mode transitions, it can freely allocate memory, farm work out to multiple threads, and so on – it’s just a regular DLL (even though it’s loaded by the API, not directly by your app).</p>
</li>
<li>
<p>If the UMD crashes, the app crashes with it, but not the whole system; it can just be replaced while the system is running (it’s just a DLL!); it can be debugged with a regular debugger.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_did_i_say_user_mode_driver_i_meant_user_mode_drivers">Did I say “user-mode driver”? I meant “user-mode drivers”.</h5>

</div>
</div>
<div class="sect3">
<h4 id="_enter_the_scheduler">Enter the scheduler.</h4>
<div class="ulist">
<ul>
<li>
<p>The graphics scheduler arbitrates access to the 3D pipeline by time-slicing it between different apps. A context switch incurs some state switching on the GPU and possibly also swapping some resources in and out of video memory.</p>
</li>
<li>
<p>Only one process gets to actually submit commands to the 3D pipe at any given time.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_the_kernel_mode_driver_kmd">The kernel-mode driver (KMD)</h4>
<div class="ulist">
<ul>
<li>
<p>There’s only ever one KMD, and if that crashes then it was a “blue screen”. By now Windows actually knows how to kill a crashed driver and reload it.</p>
</li>
<li>
<p>The KMD deals with all the things that are just there once.</p>
<div class="ulist">
<ul>
<li>
<p>allocate (and map) physical memory</p>
</li>
<li>
<p>initialize the GPU at startup</p>
</li>
<li>
<p>set display modes (and get mode information from displays)</p>
</li>
<li>
<p>manage the hardware mouse cursor</p>
</li>
<li>
<p>program the HW watchdog timer so the GPU gets reset if it stays unresponsive for a certain time</p>
</li>
<li>
<p>respond to interrupts</p>
</li>
</ul>
</div>
</li>
<li>
<p>Manages the <em>actual</em> command buffer, the one that the hardware actually consumes, it usually is a (quite small) ring buffer.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_the_bus">The bus</h5>

</div>
<div class="sect4">
<h5 id="_the_command_processor">The command processor!</h5>

</div>
</div>
<div class="sect3">
<h4 id="_small_aside_opengl">Small aside: OpenGL</h4>
<div class="ulist">
<ul>
<li>
<p>There’s not as sharp a distinction between the API and UMD layer.</p>
</li>
<li>
<p><a id="glsl-compilation"></a>The GLSL shader compilation is not handled by the API at all, it’s all done by the driver.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_omissions_and_simplifications">Omissions and simplifications</h5>

</div>
</div>
</div>
<div class="sect2">
<h3 id="_part_2_gpu_memory_architecture_and_the_command_processor">Part 2: GPU memory architecture and the Command Processor.</h3>
<div class="paragraph">
<p><a href="https://fgiesen.wordpress.com/2011/07/02/a-trip-through-the-graphics-pipeline-2011-part-2/" class="bare">https://fgiesen.wordpress.com/2011/07/02/a-trip-through-the-graphics-pipeline-2011-part-2/</a></p>
</div>
<div class="sect3">
<h4 id="_not_so_fast">Not so fast.</h4>

</div>
<div class="sect3">
<h4 id="_the_memory_subsystem">The memory subsystem</h4>
<div class="ulist">
<ul>
<li>
<p>GPUs get a massive increase in bandwidth, but they pay for it with a massive increase in latency, they are all about throughput over latency; don’t wait for results that aren’t there yet, do something else instead!</p>
</li>
<li>
<p>You can’t reach those peak memory bandwidth figures above by just reading a few bytes all over memory; if you want to saturate memory bandwidth, you better do it one full DRAM row at a time.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_the_pcie_host_interface">The PCIe host interface</h4>
<div class="ulist">
<ul>
<li>
<p>This gives the CPU read/write access to video memory and a bunch of GPU registers, the GPU read/write access to (a portion of) main memory.</p>
</li>
<li>
<p>The bandwidth is decent though – up to about 8GB/s (theoretical) peak aggregate bandwidth across the 16-lane PCIe 2.0 connections. And unlike earlier standards like AGP, this is a symmetrical point-to-point link.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_some_final_memory_bits_and_pieces">Some final memory bits and pieces</h4>
<div class="ulist">
<ul>
<li>
<p>An MMU gives you a fully virtualized address space and allows you to pull nice tricks like having frequently accessed parts of a texture in video memory, some other parts in system memory, and most of it not mapped at all.</p>
</li>
<li>
<p>It also allows you to defragment your video memory address space without having to actually copy stuff around when you start running out of video memory. And it makes it much easier to have multiple processes share the same GPU.</p>
</li>
<li>
<p><a id="dma-engine"></a>There’s also a DMA engine that can copy memory around without having to involve any of our precious 3D hardware/shader cores. Usually, this can at least copy between system memory and video memory (in both directions). It often can also copy from video memory to video memory (and if you have to do any VRAM defragmenting, this is a useful thing to have).</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_at_long_last_the_command_processor">At long last, the command processor!</h4>
<div class="ulist">
<ul>
<li>
<p>We only have a single command processor that needs to chew through our command buffer in order (since this command buffer contains things such as state changes and rendering commands that need to be executed in the right sequence). So we do the next best thing: Add a large enough buffer and prefetch far enough ahead to avoid hiccups.</p>
</li>
<li>
<p>Then there are commands that change state. GPU is a massively parallel computer, and you can’t just change a global variable in a parallel system and hope that everything works out OK</p>
<div class="ulist">
<ul>
<li>
<p>Whenever you change a state, you require that all pending work that might refer to that state be finished (i.e. basically a partial pipeline flush).</p>
</li>
<li>
<p>You can make hardware units completely stateless. Just pass the state change command through up to the stage that cares about it;</p>
</li>
<li>
<p>Say you have enough registers (“slots”) to store two versions of every state, and some active job references slot 0. You can safely modify slot 1 without stopping that job, or otherwise interfering with it at all. Now you don’t need to send the whole state around through the pipeline – only a single bit per command that selects whether to use slot 0 or 1.</p>
</li>
<li>
<p>You can use a kind of register renaming scheme – have a pool of 128 physical texture descriptors.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_synchronization">Synchronization</h4>
<div class="ulist">
<ul>
<li>
<p>All of these have the form “<em>if event X happens, do Y</em>”</p>
</li>
<li>
<p>It can be a push-model notification where the GPU yells at the CPU to do something right now.</p>
<div class="ulist">
<ul>
<li>
<p>Typically implemented using interrupts and only used for infrequent and high-priority events because interrupts are fairly expensive.</p>
</li>
</ul>
</div>
</li>
<li>
<p><a id="fences"></a>It can be a pull-model thing where the GPU just memorizes that something happened and the CPU can later ask about it (fences).</p>
<div class="ulist">
<ul>
<li>
<p>You need some CPU-visible GPU registers and a way to write values into them from the command buffer once a certain event happens.</p>
</li>
</ul>
</div>
</li>
<li>
<p><a id="semaphores"></a>if we need to synchronize purely on the GPU side the solution is a “wait”-style instruction: “<em>Wait until register M contains value N</em>”.</p>
<div class="ulist">
<ul>
<li>
<p>This can either be a compare for equality, or less-than or more fancy stuff. It allows us to build a full GPU flush operation.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_closing_remarks">Closing remarks</h5>

</div>
</div>
</div>
<div class="sect2">
<h3 id="_part_3_3d_pipeline_overview_vertex_processing">Part 3: 3D pipeline overview, vertex processing.</h3>
<div class="paragraph">
<p><a href="https://fgiesen.wordpress.com/2011/07/03/a-trip-through-the-graphics-pipeline-2011-part-3/" class="bare">https://fgiesen.wordpress.com/2011/07/03/a-trip-through-the-graphics-pipeline-2011-part-3/</a></p>
</div>
<div class="sect3">
<h4 id="_have_some_alphabet_soup">Have some Alphabet Soup!</h4>
<div class="ulist">
<ul>
<li>
<p><code>IA</code> — Input Assembler. Reads index and vertex data.</p>
</li>
<li>
<p><code>VS</code> — Vertex shader. Gets input vertex data, writes out processed vertex data for the next stage.</p>
</li>
<li>
<p><code>PA</code> — Primitive Assembly. Reads the vertices that make up a primitive and passes them on.</p>
</li>
<li>
<p><code>HS</code> — Hull shader; accepts patch primitives, writes transformed (or not) patch control points, inputs for the domain shader, plus some extra data that drives tessellation.</p>
</li>
<li>
<p><code>TS</code> — Tessellator stage. Creates vertices and connectivity for tessellated lines or triangles.</p>
</li>
<li>
<p><code>DS</code> — Domain shader; takes shaded control points, extra data from HS and tessellated positions from TS and turns them into vertices again.</p>
</li>
<li>
<p><code>GS</code> — Geometry shader; inputs primitives, optionally with adjacency information, then outputs different primitives. Also the primary hub for…</p>
</li>
<li>
<p><code>SO</code> — Stream-out. Writes GS output (i.e. transformed primitives) to a buffer in memory.</p>
</li>
<li>
<p><code>RS</code> — Rasterizer. Rasterizes primitives.</p>
</li>
<li>
<p><code>PS</code> — Pixel shader. Gets interpolated vertex data, outputs pixel colors. Can also write to UAVs (unordered access views).</p>
</li>
<li>
<p><code>OM</code> — Output merger. Gets shaded pixels from PS, does alpha blending and writes them back to the backbuffer.</p>
</li>
<li>
<p><code>CS</code> — Compute shader. In its own pipeline all by itself. Only input is constant buffers+thread ID; can write to buffers and UAVs.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_input_assembler_stage">Input Assembler stage</h4>
<div class="ulist">
<ul>
<li>
<p>The very first thing that happens here is loading indices from the index buffer – if it’s an indexed batch.</p>
</li>
<li>
<p>It usually has a data cache to exploit locality of index/vertex buffer access.</p>
</li>
<li>
<p>Note that index buffer reads are bounds checked; if you reference elements outside the original index buffer all out-of-bounds reads return zero.</p>
</li>
<li>
<p>We have a declaration of the data layout; just read it from the cache/memory and unpack it into the float format that our shader cores want for input.</p>
</li>
<li>
<p>If one vertex is referenced by multiple triangles it doesn’t need to be shaded every time – we just reference the shaded data that’s already in the cache!</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_vertex_caching_and_shading">Vertex Caching and Shading</h4>
<div class="ulist">
<ul>
<li>
<p>Reserve enough buffer space for 32 vertices (=1 batch), and similarly cache tag space for 32 entries. Start with an empty “cache”, i.e. all entries invalid. For every primitive in the index buffer, do a lookup on all the indices; if it’s a hit in the cache, fine. If it’s a miss, allocate a slot in the current batch and add the new index to the cache tag array.</p>
</li>
<li>
<p>Once we don’t have enough space left to add a new primitive anymore, dispatch the whole batch for vertex shading, save the cache tag array (i.e. the 32 indices of the vertices we just shaded), and start setting up the next batch, again from an empty cache – ensuring that the batches are completely independent.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_shader_unit_internals">Shader Unit internals</h4>
<div class="ulist">
<ul>
<li>
<p>Fast ALU mostly built around a FMAC (Floating Multiply-ACcumulate) unit, some HW support for (at least) reciprocal, reciprocal square root, log2, exp2, sin, cos</p>
</li>
<li>
<p>Optimized for high throughput and high density not low latency, running a high number of threads to cover said latency, fairly small number of registers per thread (since you’re running so many of them!)</p>
</li>
<li>
<p>Very good at executing straight-line code, bad at branches (especially if they’re not coherent).</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_closing_remarks_2">Closing remarks</h5>

</div>
</div>
</div>
<div class="sect2">
<h3 id="_part_4_texture_samplers">Part 4: Texture samplers.</h3>
<div class="paragraph">
<p><a href="https://fgiesen.wordpress.com/2011/07/04/a-trip-through-the-graphics-pipeline-2011-part-4/" class="bare">https://fgiesen.wordpress.com/2011/07/04/a-trip-through-the-graphics-pipeline-2011-part-4/</a></p>
</div>
<div class="sect3">
<h4 id="_texture_state">Texture state</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Sample state:  Filter mode, addressing mode, max anisotropy, etc.</p>
</li>
<li>
<p>Texture resource: the raw texture bits in memory. The resource also determines whether it’s a single texture or a texture array, what multisample format the texture has (if any), and the physical layout of the texture bits.</p>
</li>
<li>
<p>The Shader Resource View: determines how the texture bits are to be interpreted by the sampler.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Creating the SRV allows the API runtime to do all type checking at creation time; if you get a valid SRV back, that means the SRV and resource formats are compatible, and no further type checking needs to be done while that SRV exists.</p>
</div>
<div class="sect4">
<h5 id="_anatomy_of_a_texture_request">Anatomy of a texture request</h5>
<div class="paragraph">
<p>What information do we need to send if we want to do a 2D texture sample with up to 4x anisotropic sampling?</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The 2D texture coordinates – 2 floats, u/v and.</p>
</li>
<li>
<p>The partial derivatives of u and v along the screen “<em>x</em>” direction: \$\frac{\partial u}{\partial x}, \frac{\partial v}{\partial x}\$.</p>
</li>
<li>
<p>The partial derivative in the “<em>y</em>” direction too: \$\frac{\partial u}{\partial y}, \frac{\partial v}{\partial y}\$.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>That’s 6 floats for a fairly pedestrian 2D sampling request (of the <code>SampleGrad</code> variety). <a id="gradients"></a>The 4 gradient values are used both for mipmap selection and to choose the size and shape of the anisotropic filtering kernel.</p>
</div>
<div class="paragraph">
<p>In Pixel Shaders, turns out we don’t need to send them along with every texture request; there’s a trick that allows Pixel Shaders to give you gradient instructions (where you can compute some value and then ask the hardware “what is the approximate screen-space gradient of this value?”), and that same trick can be employed by the texture sampler to get all the required partial derivatives just from the coordinates. So for a PS 2D “sample” instruction, you really only need to send the 2 coordinates which imply the rest, provided you’re willing to do some more math in the sampler units.</p>
</div>
<div class="paragraph">
<p>What’s the worst-case number of parameters required for a single texture sample? In the current D3D11 pipeline, it’s a <code>SampleGrad</code> on a Cubemap array.</p>
</div>
<div class="paragraph">
<p>Let’s see the tally:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>3D texture coordinates – <code>u</code>, <code>v</code>, <code>w</code>: 3 floats.</p>
</li>
<li>
<p>Cubemap array index: one <code>int</code> (let’s just bill that at the same cost as a <code>float</code> here).</p>
</li>
<li>
<p>Gradient of (<code>u</code>,<code>v</code>,<code>w</code>) in the screen x and y directions: 6 floats.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For a total of 10 values per pixel sampled – that’s 40 bytes if you actually store it like that.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_but_who_asks_for_a_single_texture_sample">But who asks for a single texture sample?</h4>
<div class="paragraph">
<p>Our texture requests are coming from shader units, which we know process somewhere between 16 and 64 pixels / vertices / control points / … at once. So our shaders won’t be sending individual texture samples, they’ll dispatch a bunch of them at once.</p>
</div>
<div class="paragraph">
<p>Texture samplers have a seriously long pipeline; a texture sampling operation takes way too long for a shader unit to just sit idle for all that time. Again, say it with me: <em>throughput</em>. <a id="context_switch"></a>So what happens is that on a texture sample, a shader unit will just quietly switch to another thread/batch and do some other work, then switch back a while later when the results are there. Works just fine as long as there’s enough independent work for the shader units to do!</p>
</div>
</div>
<div class="sect3">
<h4 id="_and_once_the_texture_coordinates_arrive">And once the texture coordinates arrive…</h4>
<div class="ulist">
<ul>
<li>
<p>If this is a <code>Sample</code> or <code>SampleBias</code>-type request, calculate texture coordinate gradients first.</p>
</li>
<li>
<p>If no explicit mip level was given, calculate the mip level to be sampled from the gradients and add the LOD bias if specified.</p>
</li>
<li>
<p>For each resulting sample position, apply the address modes (wrap / clamp / mirror etc.) to get the right position in the texture to sample from, in normalized [0,1] coordinates.</p>
</li>
<li>
<p>If this is a cubemap, we also need to determine which cube face to sample from (based on the absolute values and signs of the u/v/w coordinates), and do a division to project the coordinates onto the unit cube so they are in the [-1,1] interval. We also need to drop one of the 3 coordinates (based on the cube face) and scale/bias the other 2 so they’re in the same [0,1] normalized coordinate space we have for regular texture samples.</p>
</li>
<li>
<p>Next, take the [0,1] normalized coordinates and convert them into fixed-point pixel coordinates to sample from – we need some fractional bits for the bilinear interpolation.</p>
</li>
<li>
<p>Finally, from the integer x/y/z and texture array index, we can now compute the address to read texels from.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_texture_cache">Texture cache</h4>
<div class="paragraph">
<p>Everyone seems to be using a two-level texture cache these days.
<a id="mip_mapping"></a>Most texture sampling is done in Pixel Shaders with mip-mapping enabled, and the mip level for sampling is specifically chosen to make the screen pixel:texel ratio roughly 1:1 – that’s the whole point. But this means that, unless you happen to hit the exact same location in a texture again and again, each texture sampling operation will miss about 1 texel on average – the actual measured value with bilinear filtering is around 1.25 misses/request.</p>
</div>
<div class="paragraph">
<p><em>Any</em> texture cache whatsoever is a massive win (since it drops you down from about 4 memory accesses per bilinear sample down to 1.25). But unlike with a CPU or shared memory for shader cores, there’s very little gain in going from say 4k of cache to 16k; we’re streaming larger texture data through the cache no matter what.</p>
</div>
<div class="paragraph">
<p>Because of the 1.25 misses/sample average, texture sampler pipelines need to be long enough to sustain a full read from memory per sample without stalling. Texture sampler pipes are long enough to not stall for a memory read even though it takes 400-800 cycles.</p>
</div>
<div class="paragraph">
<p>Compressed texture formats are all block-based methods that encode blocks of 4×4 pixels individually. If you decode them during texture sampling, that means you need to be able to decode up to 4 such blocks (if your 4 bilinear sample points happen to land in the worst-case configuration of straddling 4 blocks) per cycle and get a single pixel from each. Instead, the 4×4 blocks are decoded when it’s brought into the L1 cache: in the case of BC3 (aka DXT5), you fetch one 128-bit block from texture L2, and then decode that into 16 pixels in the texture cache. And suddenly, instead of having to partially decode up to 4 blocks per sample, you now only need to decode 1.25/(4*4) = about 0.08 blocks per sample, at least if your texture access patterns are coherent enough to hit the other 15 pixels you decoded alongside the one you actually asked for :)</p>
</div>
</div>
<div class="sect3">
<h4 id="_filtering">Filtering</h4>
<div class="paragraph">
<p>Bilinear filtering process is fairly straightforward. Grab 4 samples from the texture cache, use the fractional positions to blend between them. Trilinear filtering? Two bilinear samples and another linear interpolation.</p>
</div>
<div class="paragraph">
<p>Anisotropic filtering? What we do is look at the gradients to determine not just the area but also the shape of a screen pixel in texel space; if it’s roughly as wide as it is high, we just do a regular bilinear/trilinear sample, but if it’s elongated in one direction, we do several samples across that line and blend the results together. This generates several sample positions, so we end up looping through the full bilinear/trilinear pipeline several times, and the actual way the samples are placed and their relative weights are computed is a closely guarded secret for each hardware vendor.</p>
</div>
</div>
<div class="sect3">
<h4 id="_texture_returns">Texture returns</h4>
<div class="paragraph">
<p>What’s the result of all this? Up to 4 values (r, g, b, a) per texture sample requested. Unlike texture requests where there’s significant variation in the size of requests, here the most common case by far is just the shader consuming all 4 values.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_usual_post_script">The usual post-script</h4>
<div class="paragraph">
<p>As for texture L1 cache containing decompressed texture data, to the best of my knowledge this is accurate for current hardware. Some older HW would keep some formats compressed even in L1 texture cache, but because of the “1.25 misses/sample for a large range of cache sizes” rule, that’s not a big win and probably not worth the complexity.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_part_5_primitive_assembly_clipcull_projection_and_viewport_transform">Part 5: Primitive Assembly, Clip/Cull, Projection, and Viewport transform.</h3>
<div class="paragraph">
<p><a href="https://fgiesen.wordpress.com/2011/07/05/a-trip-through-the-graphics-pipeline-2011-part-5/" class="bare">https://fgiesen.wordpress.com/2011/07/05/a-trip-through-the-graphics-pipeline-2011-part-5/</a></p>
</div>
<div class="sect3">
<h4 id="_primitive_assembly">Primitive Assembly</h4>
<div class="paragraph">
<p>We had just gotten a block of shaded vertices back from the shader units, with the implicit promise that this block contains an integral number of primitives – i.e., we don’t allow triangles, lines or patches to be split across multiple blocks.</p>
</div>
<div class="paragraph">
<p>All that happens here is that we gather vertices. We can either do this by reading the original index buffer and keeping a copy of our vertex index&#8594;cache position map around, or we can store the indices for the fully expanded primitives along with the shaded vertex data, which might take a bit more space for the output buffer but means we don’t have to read the indices again here.</p>
</div>
</div>
<div class="sect3">
<h4 id="_viewport_culling_and_clipping">Viewport culling and clipping</h4>
<div class="paragraph">
<p>You can look polygon clipping up in chapter 13 of this Jim Blinn&#8217;s <a href="http://www.amazon.com/Jim-Blinns-Corner-Graphics-Pipeline/dp/1558603875">book</a>.</p>
</div>
<div class="paragraph">
<p>Your vertex shader returns vertex positions on homogeneous clip space. Clip space is chosen to make the equations that describe the view frustum as simple as possible; in the case of D3D, they are \$-w \le x \le w, -w \le y \le w, 0 \le z \le w\$, and \$0 &lt; w\$; note that all the last equation really does is exclude the homogeneous point (0,0,0,0), which is something of a degenerate case.</p>
</div>
<div class="paragraph">
<p>We first need to find out if the triangle is partially or even completely outside any of these clip planes. This can be done very efficiently using <a href="http://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland">Cohen-Sutherland</a>-style out-codes. You compute the clip out-code for each vertex then, for each primitive, the bitwise AND of the clip-codes will tell you all the view-frustum planes that all vertices in the primitive are on the wrong side of and the bitwise OR of the clip-codes will tell you the planes that you need to clip the primitive against.</p>
</div>
<div class="paragraph">
<p>The actual clipping process, if invoked, can take one of two forms: we can either use an actual polygon clipping algorithm (which adds extra vertices and triangles), or we can add the clipping planes as extra edge equations to the rasterizer.</p>
</div>
</div>
<div class="sect3">
<h4 id="_guard_band_clipping">Guard-band clipping</h4>
<div class="paragraph">
<p>Most primitives that are partially outside the left, right, top and bottom clip planes don’t need to be clipped at all. Triangle rasterization on GPUs works by, in effect, scanning over the full screen area and asking if a pixel is covered by the current triangle. And that works just as well for triangles completely within the viewport as it does for triangles that extend past, say, the right and top clipping planes. As long as our triangle coverage test is reliable, we don’t need to clip against the left, right, top and bottom planes at all!</p>
</div>
<div class="paragraph">
<p>The solution is to clip triangles eventually, just as they’re about to go outside the safe range where the rasterizer calculations can’t overflow. For example, say that your rasterizer has enough internal bits to deal with integer triangle coordinates that have \$-32768 \le X \le 32767, -32768 \le Y \le 32767\$. You still do your viewport cull test with the regular view planes, but only actually clip against the guard-band clip planes which are chosen so that after the projection and viewport transforms, the resulting coordinates are in the safe range.</p>
</div>
</div>
<div class="sect3">
<h4 id="_aside_getting_clipping_right">Aside: Getting clipping right</h4>
<div class="paragraph">
<p>Here’s some of the non-obvious rules the triangle clipper has to obey in practice. If it ever breaks any of these rules, there’s cases where it will produce cracks between adjacent triangles that share an edge.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Vertex positions that are inside the view frustum must be preserved, bit-exact, by the clipper.</p>
</li>
<li>
<p>Clipping an edge AB against a plane must produce the same results, bit-exact, as clipping the edge BA (orientation reversed) against that plane. (This can be ensured by either making the math completely symmetric, or always clipping an edge in the same direction, say from the outside in).</p>
</li>
<li>
<p>Primitives that are clipped against multiple planes must always clip against planes in the same order. (Either that or clip against all planes at once)</p>
</li>
<li>
<p>If you use a guard band, you must clip against the guard band planes; you can’t use a guard band for some triangles but then clip against the original viewport planes if you actually need to clip.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_those_pesky_near_and_far_planes">Those pesky near and far planes</h4>
<div class="paragraph">
<p>What about near and far? Particularly the near plane is bothersome, since with all the stuff that’s only slightly outside the viewport handled, that’s the plane we do most of our clipping for.</p>
</div>
<div class="paragraph">
<p>So we’re down to one of the regular clip planes: \$0 &lt; w\$. Can we get rid of this one too? The answer is yes, with a rasterization algorithm that works in homogeneous coordinates, e.g. <a href="http://www.cs.unc.edu/~olano/papers/2dh-tri/">this one</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_projection_and_viewport_transform">Projection and viewport transform</h4>
<div class="paragraph">
<p>Projection just takes the x, y and z coordinates and divides them by w. <a id="ndc"></a>This gives us normalized device coordinates, or NDCs, between -1 and 1. We then apply the viewport transform which maps the projected x and y to pixel coordinates (which I’ll call X and Y) and the projected z into the range [0,1] (I’ll call this value Z), such that at the z-near plane Z=0 and at the z-far plane Z=1.</p>
</div>
<div class="paragraph">
<p>At this point, we also snap pixels to fractional coordinates on the sub-pixel grid. As of D3D11, hardware is required to have exactly 8 bits of subpixel precision for triangle coordinates. This snapping turns some very thin slivers (which would otherwise cause problems) into degenerate triangles (which don’t need to be rendered at all).</p>
</div>
</div>
<div class="sect3">
<h4 id="_back_face_and_other_triangle_culling">Back-face and other triangle culling</h4>
<div class="paragraph">
<p>Once we have the X and Y for all vertices, we can calculate the signed triangle area using a cross product of the edge vectors. If the area is negative, the triangle is wound counter-clockwise. If the area is positive, it’s wound clockwise. If it’s zero, it’s degenerate and doesn’t cover any pixels, so it can be safely culled. At this point, we know the triangle orientation so we can do back-face culling (if enabled).</p>
</div>
</div>
<div class="sect3">
<h4 id="_final_remarks">Final remarks</h4>
<div class="paragraph">
<p>I skipped some parts and simplified others, so here’s the usual reminder that things are a bit more complicated in reality.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_part_6_triangle_rasterization_and_setup">Part 6: (Triangle) rasterization and setup.</h3>
<div class="paragraph">
<p><a href="https://fgiesen.wordpress.com/2011/07/06/a-trip-through-the-graphics-pipeline-2011-part-6/" class="bare">https://fgiesen.wordpress.com/2011/07/06/a-trip-through-the-graphics-pipeline-2011-part-6/</a></p>
</div>
<div class="sect3">
<h4 id="_how_not_to_render_a_triangle">How <em>not</em> to render a triangle</h4>
<div class="paragraph">
<p>In hardware, the “triangle rasterizer” is a block that tells you what (sub-)pixels a triangle covers; in some cases, it’ll also give you barycentric coordinates of those pixels inside the triangle. But that’s it.</p>
</div>
<div class="paragraph">
<p>If you’ve written your own triangle mappers “back in the day”, you probably used an incremental scanline rasterizer of the kind described in Chris Hecker’s <a href="http://chrishecker.com/Miscellaneous_Technical_Articles">series on Perspective Texture Mapping</a>. That happens to be a great way to do it in sofware on processors without SIMD units, but it doesn’t map well to modern processors with fast SIMD units, and even worse to hardware.</p>
</div>
</div>
<div class="sect3">
<h4 id="_a_better_way">A better way</h4>
<div class="paragraph">
<p>A much simpler (and more hardware-friendly) way to rasterize triangles was presented in a 1988 <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.157.4621&amp;rep=rep1&amp;type=pdf">paper</a> by Pineda. The general approach can be summarized in 2 sentences: the signed distance to a line can be computed with a 2D dot product (plus an add) – just as a signed distance to a plane can be compute with a 3D dot product (plus add). And the interior of a triangle can be defined as the set of all points that are on the correct side of all three edges. So… just loop over all candidate pixels and test whether they’re actually inside the triangle.</p>
</div>
<div class="paragraph">
<p>Our edge equations have the form \$E(X,Y) = aX + bY + c\$, with a, b, c being per-triangle constants, so for X+1 it will be \$E(X+1,Y) = a(X+1) + bY + c = E(X,Y) + a\$. In other words, once you have the values of the edge equations at a given point, the values of the edge equations for adjacent pixels are just a few adds away. Also note that this is absolutely trivial to parallelize.</p>
</div>
<div class="paragraph">
<p>You just compute \$ia + jb\$ for \$0 \le i, j \le 7\$ once for each triangle (and edge) and keep that in registers; then, to rasterize a 8×8 block of pixels, you just compute the 3 edge equation for the top-left corner, fire off 8×8 parallel adds of the constants we’ve just computed, and then test the resulting sign bits to see whether each of the 8×8 pixels is inside or outside that edge. Do that for 3 edges, and presto, one 8×8 block of a triangle rasterized in a truly embarrassingly parallel fashion.</p>
</div>
<div class="paragraph">
<p>There’s another thorny bit here, which is fill rules; you need to have tie-breaking rules to ensure that for any pair of triangles sharing an edge, no pixel near that edge will ever be skipped or rasterized twice. D3D and OpenGL both use the so-called “top-left” fill rule; with this kind of integer rasterizer, it boils down to subtracting 1 from the constant term on some edges during triangle setup.</p>
</div>
</div>
<div class="sect3">
<h4 id="_what_we_need_around_here_is_more_hierarchy">What we need around here is more hierarchy</h4>
<div class="paragraph">
<p>What I’ve just described is what the “fine” rasterizer does (the one that actually outputs sample coverage). Now, to avoid wasted work at the pixel level, what we do is add another rasterizer in front of it that doesn’t rasterize the triangle into pixels, but “tiles” – our 8×8 blocks (<a href="http://people.csail.mit.edu/ericchan/bib/pdf/p15-mccormack.pdf">This</a> paper by McCormack and McNamara has some details, as does Greene’s <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.115.1646&amp;rep=rep1&amp;type=pdf">“Hierarchical Polygon Tiling with Coverage Masks”</a> that takes the idea to its logical conclusion).</p>
</div>
<div class="paragraph">
<p>We can think this idea further, as in Greene’s paper or Mike Abrash’s description of <a href="http://drdobbs.com/architecture-and-design/217200602">Rasterization on Larrabee</a>, and do a full hierarchical rasterizer. But with a hardware rasterizer, there’s little to no point: it actually increases the amount of work done for small triangles.</p>
</div>
<div class="paragraph">
<p>The problem is small triangles! Even if you have a bunch of tiny triangles that generate 0 or 1 visible pixels, you still need to go through triangle setup, at least one step of coarse rasterization, and then at least one fine rasterization step for an 8×8 block. With tiny triangles, it’s easy to get either triangle setup or coarse rasterization bound.</p>
</div>
<div class="paragraph">
<p><a id="slivers"></a>One thing to note is that with this kind of algorithm, slivers (long, very thin triangles) are seriously bad news – you need to traverse tons of tiles and only get very few covered pixels for each of them.</p>
</div>
</div>
<div class="sect3">
<h4 id="_so_what_does_triangle_setup_do">So what does triangle setup do?</h4>
<div class="ulist">
<ul>
<li>
<p>The edge equations – a, b, c for all 3 triangle edges.</p>
</li>
<li>
<p>Some of the derived values, like the \$ia + jb\$ for 0 \$\le i, j \le 7\$ that I mentioned; note that you wouldn’t actually store a full 8×8 matrix of these in hardware, certainly not if you’re gonna add another value to it anyway. The best way to do this is in HW probably to just compute the \$ia\$ and \$jb\$, use a <a href="http://en.wikipedia.org/wiki/Carry-save_adder">Carry-save adder</a> (aka 3:2 reducer, I wrote about them <a href="https://fgiesen.wordpress.com/2010/08/23/carry-save-adders-and-averaging-bit-packed-values/">before</a>) to reduce the \$ia + jb + c\$ expression to a single sum, and then finish that off with a regular adder.</p>
</li>
<li>
<p>Which reference corner of the tiles to use to get the upper/lower bounds of the edge equations for coarse rasterizer.</p>
</li>
<li>
<p>The initial value of the edge equations at the first reference point for the coarse rasterizer (adjusted for fill rule).</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_other_rasterization_issues_and_pixel_output">Other rasterization issues and pixel output</h4>
<div class="paragraph">
<p><a id="scissor_test"></a>One thing I didn’t mention so far is the scissor rect. That’s just a screen-aligned rectangle that masks pixels; no pixel outside that rect will be generated by the rasterizer. This is fairly easy to implement – the coarse rasterizer can just reject tiles that don’t overlap the scissor rect outright, and the fine rasterizer ANDs all generated coverage masks with the “rasterized” scissor rectangle (where “rasterization” here boils down to a one integer compare per row and column and some bitwise ANDs).</p>
</div>
<div class="paragraph">
<p><a id="msaa"></a>Another issue is multisample antialiasing. What changes is now you have to test more samples per pixel – as of DX11, HW needs to support at least 8x MSAA. Note that the sample locations inside each pixel aren’t on a regular grid, but dispersed to give good results across a wide range of multiple edge orientations. These irregular sample locations are a total pain to deal with in a scanline rasterizer but very easy to support in a Pineda-style algorithm: it boils down to computing a few more per-edge offsets in triangle setup and multiple additions/sign tests per pixel instead of just one.</p>
</div>
</div>
<div class="sect3">
<h4 id="_caveats">Caveats</h4>
<div class="paragraph">
<p><a id="mobile_tiled"></a>Another implicit assumption in this article is that we’re on high-end PC hardware; a lot of parts, particularly in the mobile/embedded range, are so-called tile renderers, which partition the screen into tiles and render each of them individually. These are not the same as the 8×8 tiles for rasterization I used throughout this article. Tiled renderers need at least another “ultra-coarse” rasterization stage that runs early and finds out which of the (large) tiles are covered by each triangle; this stage is usually called “binning”.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_part_7_zstencil_processing_3_different_ways">Part 7: Z/Stencil processing, 3 different ways.</h3>
<div class="paragraph">
<p><a href="https://fgiesen.wordpress.com/2011/07/08/a-trip-through-the-graphics-pipeline-2011-part-7/" class="bare">https://fgiesen.wordpress.com/2011/07/08/a-trip-through-the-graphics-pipeline-2011-part-7/</a></p>
</div>
<div class="sect3">
<h4 id="_interpolated_values">Interpolated values</h4>
<div class="paragraph">
<p>Just linearly interpolating attributes (colors, texture coordinates etc.) across the screen-space triangle does not produce the right results. However, say we want to interpolate a 2D texture coordinate pair \$(s,t)\$. It turns out you do get the right results if you linearly interpolate \$\frac{1}{w}\$, \$\frac{s}{w}\$ and \$\frac{t}{w}\$ in screen-space (w here is the homogeneous clip-space w from the vertex position), then per-pixel take the reciprocal of \$\frac{1}{w}\$ to get w, and finally multiply the other two interpolated fractions by w to get s and t.</p>
</div>
<div class="paragraph">
<p>The actual linear interpolation boils down to setting up a plane equation and then plugging the screen-space coordinates in. But if you’re interpolating more than two values, a better approach is to compute (using perspective interpolation) barycentric coordinates – let’s call them \$\lambda_0\$ and \$\lambda_1\$ – for the current pixel in the original clip-space triangle, after which you can interpolate the actual vertex attributes using regular linear interpolation without having to multiply everything by w afterwards.</p>
</div>
<div class="paragraph">
<p>Setting up the \$\frac{\lambda_0}{w}\$ and \$\frac{\lambda_1}{w}\$ for the triangle requires 4 reciprocals, the triangle area (which we already computed for back-face culling!), and a few subtractions, multiplies and adds. Setting up the vertex attributes for interpolation is really cheap with the barycentric approach – two subtractions per attribute.</p>
</div>
<div class="paragraph">
<p>Now we want to interpolate Z, and because we computed Z as \$\frac{z}{w}\$ at the vertex level as part of projection, it’s already divided by w and we can just interpolate it linearly in screen space. What we end up with is a plane equation for \$Z = aX + bY + c\$ that we can just plug X and Y into to get a value.</p>
</div>
</div>
<div class="sect3">
<h4 id="_early_zstencil"><a id="early_z"></a>Early Z/Stencil</h4>
<div class="paragraph">
<p>So what GPUs actually do when they can is called “early Z” (as opposed to late Z, which is actually at the late stage in the pipeline that traditional API models generally display it at). This executes the Z/stencil tests and writes early, right after the triangle has been rasterized, and before we start sending off pixels to the shaders. That way, we notice all the rejected pixels early, without wasting a lot of computation on them. However, we can’t always do this: the pixel shader may ignore the interpolated depth value, and instead provide its own depth to be written to the Z-buffer (e.g. depth sprites); or it might use discard, alpha test, or alpha-to-coverage, all of which “kill” pixels/samples during pixel shader execution and mean that we can’t update the Z-buffer or stencil buffer early because we might be updating depth values for samples that later get discarded in the shader!</p>
</div>
<div class="paragraph">
<p>Traditionally, APIs just pretended none of this early-out logic existed; Z/Stencil was in a late stage in the original API model, and any optimizations such as early-Z had to be done in a way that was 100% functionally consistent with that model; i.e. drivers had to detect when early-Z was applicable, and could only turn it on when there were no observable differences. By now APIs have closed that gap; as of DX11, shaders can be declared as “force early-Z”, which means they run with full early-Z processing even when the shader uses primitives that aren’t necessarily “safe” for early-Z, and shaders that write depth can declare that the interpolated Z value is conservative (i.e. early Z reject can still happen).</p>
</div>
</div>
<div class="sect3">
<h4 id="_zstencil_writes_the_full_truth">Z/stencil writes: the full truth</h4>
<div class="paragraph">
<p>Switching from a shader that does early Z to one that does late Z is no problem. But going back from late Z to early Z is, if early Z does any writes: early Z is, well, earlier in the pipeline than late Z – that’s the whole point! So we may start early-Z processing for one shader, merrily writing to the depth buffer while there’s still stuff down in the pipeline for our old shader that’s running late-Z and may be trying to write the same location at the same time – classic race condition. So how do we fix this?</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Once you go from early-Z to late-Z processing within a render target, you stay at late-Z until the next point where you flush the pipeline anyway. This works but potentially wastes lots of shader cycles while early-Z is unnecessarily off.</p>
</li>
<li>
<p>Trigger a (pixel) pipeline flush when going from a late-Z shader to an early-Z shader – also works, also not exactly subtle. This time, we don’t waste shader cycles (or memory bandwidth) but stall instead – not much of an improvement.</p>
</li>
<li>
<p>Another option is to not ever write Z in the early-Z phase; always do the Z-writes in late-Z. Note that you need to be careful to make conservative Z-testing decisions during early Z if you do this! This avoids the race condition but means the early Z-test results may be stale because the Z-write for the currently-dispatched pixels won’t happen until a while later.</p>
</li>
<li>
<p>Use a separate unit that keeps track of Z-writes for us and enforces the correct ordering; both early-Z and late-Z must go through this unit.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_hierarchical_zstencil">Hierarchical Z/Stencil</h4>
<div class="paragraph">
<p>The idea here is that we can use our tile trick from rasterization again, and try to Z-reject whole tiles at a time, before we even descend down to the pixel level! What we do here is a strictly conservative test; it may tell us that “<em>there might be pixels that pass the Z/stencil-test in this tile</em>” when there are none, but it will never claim that all pixels are rejected when in fact they weren’t.</p>
</div>
<div class="paragraph">
<p>Assume here that we’re using “less”, “less-equal”, or “equal” as Z-compare mode. Then we need to store the maximum Z-value we’ve written for that tile, per tile. When rasterizing a triangle, we calculate the minimum Z-value the active triangle is going to write to the current tile (one easy conservative approximation is to take the min of the interpolated Z-values at the four corners of the current tile). If our triangle minimum-Z is larger than the stored maximum-Z for the current tile, the triangle is guaranteed to be completely occluded.</p>
</div>
<div class="paragraph">
<p>What we can’t easily do is change from one of the “less”-based tests to a “greater”-based tests in the middle of the frame, because that would make the information we’ve been tracking useless. What GPUs actually do is turn hierarchical-Z off once you do this (up until the next Clear).</p>
</div>
<div class="paragraph">
<p>Similar to the hierarchical-Z logic I’ve described, current GPUs also have hierarchical stencil processing.</p>
</div>
<div class="sect4">
<h5 id="_putting_it_all_together">Putting it all together</h5>

</div>
</div>
<div class="sect3">
<h4 id="_revenge_of_the_api_order">Revenge of the API order</h4>
<div class="paragraph">
<p>For Z-compare modes like “less” or “lessequal”, it’s very important what order the pixels arrive in; if we mess with that, we risk changing the results and introducing nondeterministic behavior.</p>
</div>
<div class="paragraph">
<p>In our current path, the best candidate location to sort things into order again seems to be primitive assembly; so when we start assembling primitives from shaded vertex blocks, we make sure to assemble them strictly in the original order as submitted by the app to the API.</p>
</div>
</div>
<div class="sect3">
<h4 id="_memory_bandwidth_and_z_compression">Memory bandwidth and Z compression</h4>
<div class="paragraph">
<p>The second big point is that Z/Stencil is a serious bandwidth hog. This has a couple of reasons. For one, this is the one thing we really run for all samples generated by the rasterizer. The other big reason is that, when multisampling is enabled, the Z/stencil buffer is per sample; so 4x MSAA means 4x the memory bandwidth cost of Z.</p>
</div>
<div class="paragraph">
<p>So what GPUs do is Z compression. There’s various approaches, but the general idea is always the same: assuming reasonably-sized triangles, we expect a lot of tiles to just contain one or maybe two triangles. If that happens, then instead of storing Z-values for the whole tile, we just store the plane equation of the triangle that filled up this tile. That plane equation is (hopefully) smaller than the actual Z data. Without MSAA, one tile covers 8×8 actual pixels, so triangles need to be relatively big to cover a full tile; but with 4x MSAA, a tile effectively shrinks to 4×4 pixels.</p>
</div>
<div class="paragraph">
<p>When this compression works is fully lossless, but it’s not applicable to all tiles. So we need some extra space to denote whether a tile is compressed or not. We add some dedicated SRAM that allows us to store a few (1-3) bits per tile. At its simplest, it’s just a “compressed” or “not compressed” flag, but you can get fancy and add multiple compression modes and such. <a id="fast_z_clear"></a>A nice side effect of Z-compression is that it allows us to do fast Z-clears: e.g. when clearing to Z=1, we just set all tiles to “compressed” and store the plane equation for a constant Z=1 triangle.</p>
</div>
<div class="sect4">
<h5 id="_postscript">Postscript</h5>

</div>
</div>
</div>
<div class="sect2">
<h3 id="_part_8_pixel_processing_fork_phase">Part 8: Pixel processing – “fork phase”.</h3>
<div class="paragraph">
<p><a href="https://fgiesen.wordpress.com/2011/07/10/a-trip-through-the-graphics-pipeline-2011-part-8/" class="bare">https://fgiesen.wordpress.com/2011/07/10/a-trip-through-the-graphics-pipeline-2011-part-8/</a></p>
</div>
<div class="sect3">
<h4 id="_going_wide_during_rasterization">Going wide during rasterization</h4>
<div class="paragraph">
<p>GPU architects started using multiple rasterizers; as of 2010, <a href="http://www.highperformancegraphics.org/previous/www_2010/media/Hot3D/HPG2010_Hot3D_NVIDIA.pdf">NVidia employs four rasterizers</a> and <a href="http://www.highperformancegraphics.org/previous/www_2010/media/Hot3D/HPG2010_Hot3D_AMD.pdf">AMD uses two</a>.</p>
</div>
<div class="paragraph">
<p>The work distribution between rasterizers is based on the tiles we’ve already seen for early-Z and coarse rasterization. The frame buffer is divided into tile-sized regions, and each region is assigned to one of the rasterizers. After setup, the bounding box of the triangle is consulted to find out which triangles to hand over to which rasterizers; large triangles will always be sent to all rasterizers, but smaller ones can hit as little as one tile and will only be sent to the rasterizer that owns it.</p>
</div>
</div>
<div class="sect3">
<h4 id="_you_need_to_go_wider">You need to go wider!</h4>
<div class="paragraph">
<p><a id="nvidia_warp"></a>For NVidia (they mention this number in <a href="http://www.nvidia.com/content/PDF/fermi_white_papers/NVIDIA_Fermi_Compute_Architecture_Whitepaper.pdf">public white papers</a>), the unit of dispatch to shader units is 32 threads, which they call a “Warp”. Each quad has 4 pixels (each of which in turn can be handled as one thread), so for each shading batch we issue, we need to grab 8 incoming quads from the rasterizer before we can send off a batch to the shader units.</p>
</div>
<div class="paragraph">
<p>This is a good point to explain why we’re dealing with quads of 2×2 pixels and not individual pixels. The big reason is derivatives. Texture samplers depend on screen-space derivatives of texture coordinates to do their mip-map selection and filtering; and, as of shader model 3.0 and later, the same machinery is directly available to pixel shaders in the form of derivative instructions. In a quad, each pixel has both a horizontal and vertical neighbor within the same quad; this can be used to estimate the derivatives of parameters in the x and y directions using finite differencing (it boils down to a few subtractions). This gives you a very cheap way to get derivatives at the cost of always having to shade groups of 2×2 pixels at once.</p>
</div>
<div class="paragraph">
<p>This is no problem in the interior of large triangles, but means that between 25-75% of the shading work for quads generated for triangle edges is wasted. That’s because all pixels in a quad, even the masked ones, get shaded. This is necessary to produce correct derivatives for the pixels in the quad that are visible. <a id="helper_pixels"></a>The invisible but still-shaded pixels are called “helper pixels”. For small triangles, a large fraction of the total number of pixels shaded are helper pixels, which has attracted some <a href="http://graphics.stanford.edu/papers/fragmerging/shade_sig10.pdf">research attention</a> on how to merge quads of adjacent triangles.</p>
</div>
</div>
<div class="sect3">
<h4 id="_attribute_interpolation">Attribute interpolation</h4>
<div class="paragraph">
<p>Another unique feature of pixel shaders is attribute interpolation. A plane equation is computed for attributes during triangle setup and then during pixel shading, there’s a separate unit that performs interpolation using the pixel positions of the quads and the plane equations we just computed.</p>
</div>
<div class="paragraph">
<p>There used to be dedicated interpolators, by now the trend is towards just having them return the barycentric coordinates to plug into the plane equations. The actual evaluation (two multiply-adds per attribute) can be done in the shader unit.</p>
</div>
<div class="paragraph">
<p>There’s a few extra interpolation types to discuss. First, there’s “constant” interpolators, which are constant across the primitive and take the value for each vertex attribute from the “leading vertex” then there’s no-perspective interpolation. Those attributes are cheaper to evaluate when their plane equation is set up for X, Y-based interpolation without dividing the values at each vertex by the corresponding w.</p>
</div>
</div>
<div class="sect3">
<h4 id="_centroid_interpolation_is_tricky">“Centroid” interpolation is tricky</h4>
<div class="paragraph">
<p>Next, we have “centroid” interpolation. It can be combined both with the perspective and no-perspective modes and a no-op unless multisampling is enabled.
GPU takes all of the samples covered by the primitive, computes their centroid, and samples at that position.</p>
</div>
<div class="paragraph">
<p>Here’s what actually happens:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If all sample points cover the primitive, interpolation is done as usual, i.e. at the pixel center (which happens to be the centroid of all sample positions for all reasonable sampling patterns).</p>
</li>
<li>
<p>If not all sample points cover the triangle, the hardware picks one of the sample points that do and evaluates there. All covered sample points are (by definition) inside the primitive so this works.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Finally (new in DX11!) there’s “pull-model” attribute interpolation. Regular attribute interpolation is done automatically before the pixel shader starts; pull-model interpolation adds actual instructions that do the interpolation to the pixel shader.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_actual_shader_body">The actual shader body</h4>
<div class="paragraph">
<p>There are some interesting bits about pixel shader execution that are worth talking about.</p>
</div>
<div class="paragraph">
<p>The first one is: texture sampling! <a id="context_switch2"></a>What shader units actually do is switch to a different batch after they’ve issued a texture sample; then when that batch issues a texture sample (or completes), it switches back to one of the previous batches and checks if the texture samples are there yet. As long as each shader unit has a few batches it can work on at any given time, this makes good use of available resources. One thing to note here is that keeping multiple batches (or “Warps” on NVidia hardware, or “Wavefronts” for AMD) running at the same time requires more registers. If a shader needs a lot of registers, a shader unit can keep less warps around; and if there are less of them, the chance that at some point you’ll run out of runnable batches that aren’t waiting on texture results is higher. If there’s no runnable batches, you’re out of luck and have to stall until one of them gets its results back.</p>
</div>
<div class="paragraph">
<p>Another point I haven’t talked about yet: Dynamic branches in shaders (i.e. loops and conditionals). <a id="lockstep_execution"></a>In shader units, work on all elements of each batch usually proceeds in lockstep. All “threads” run the same code, at the same time. That means that ifs are a bit tricky: If any of the threads want to execute the “then”-branch of an if, all of them have to – even though most of them may end up ignoring the results using a technique called <a href="http://en.wikipedia.org/wiki/Branch_predication">predication</a>, because they didn’t want to descend down there in the first place. Similarly for the “else” branch. This works great if conditionals tend to be coherent across elements, and not so great if they’re more or less random. Worst case, you’ll always execute both branches of every if.</p>
</div>
<div class="paragraph">
<p><a id="discard"></a>Another pixel shader specific is the <code>discard</code> instruction. A pixel shader can decide to “kill” the current pixel, which means it won’t get written. Again, if all pixels inside a batch get discarded, the shader unit can stop and go to another batch; but if there’s at least one thread left standing, the rest will be dragged along. DX11 adds more fine-grained control here by way of writing the output pixel coverage from the pixel shader (this is always ANDed with the original triangle/Z-test coverage, to make sure that a shader can’t write outside its primitive, for sanity). This allows the shader to discard individual samples instead of whole pixels; it can be used to implement Alpha-to-Coverage with a custom dithering algorithm in the shader, for example.</p>
</div>
<div class="paragraph">
<p>Pixel shaders can also write the output depth: this is an excellent way to shoot down early-Z, hierarchical Z and Z compression and in general get the slowest path possible.</p>
</div>
<div class="paragraph">
<p>There’s one final thing that pixel shaders can do starting with D3D11: they can write to Unordered Access Views (UAVs) – something which only compute and pixel shaders can do. Generally speaking, UAVs take the place of render targets during compute shader execution; but unlike render targets, the shader can determine the position to write to itself, and there’s no implicit API order guarantee (hence the “unordered access” part of the name).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_part_9_pixel_processing_join_phase">Part 9: Pixel processing – “join phase”.</h3>
<div class="paragraph">
<p><a href="https://fgiesen.wordpress.com/2011/07/12/a-trip-through-the-graphics-pipeline-2011-part-9/" class="bare">https://fgiesen.wordpress.com/2011/07/12/a-trip-through-the-graphics-pipeline-2011-part-9/</a></p>
</div>
<div class="sect3">
<h4 id="_merging_pixels_again_blend_and_late_z">Merging pixels again: blend and late Z</h4>
<div class="paragraph">
<p>At the bottom of the pipeline (in what D3D calls the “Output Merger” stage), we have late Z/stencil processing and blending. These two operations are both relatively simple computationally, and they both update the render target(s) / depth buffer respectively. Because all of this happens for every quad that makes it this far through the pipeline, it’s also bandwidth-intensive. Finally, it’s order-sensitive.</p>
</div>
<div class="paragraph">
<p>Blending is one of these things that work pretty much as you’d expect; it’s a fixed-function block that performs a multiply, a multiply-add and maybe some subtractions first, per render target. This block is kept deliberately simple; it’s separate from the shader units so it needs its own ALU. It has a short, predictable latency: this part of the pipeline needs to process data in-order to be correct. This limits our options as far as trading throughput for latency is concerned; we can still process quads that don’t overlap in parallel.</p>
</div>
</div>
<div class="sect3">
<h4 id="_meet_the_rops">Meet the ROPs</h4>
<div class="paragraph">
<p>ROPs are the hardware units that handle this part of the pipeline. The acronym, depending on who you asks, stands for “Render OutPut unit”, “Raster Operations Pipeline”, or “Raster Operations Processor”. The actual name is fairly archaic – it derives from the days of pure 2D hardware acceleration, with hardware whose main purpose was to do fast <a href="https://en.wikipedia.org/wiki/Bit_blit">Bit blits</a>.</p>
</div>
<div class="paragraph">
<p>So what do we need to do, in hardware, for blend/late Z? A simple plan:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Read original render target/depth buffer contents from memory – memory access, long latency. Might also involve depth buffer and render target decompression!</p>
</li>
<li>
<p>Sort incoming shaded quads into the right (API) order. This takes some buffering so we don’t immediately stall when quads don’t finish in the right order (think loops/branches, discard, and variable texture fetch latency). Note we only need to sort based on primitive ID here – two quads from the same primitive can never overlap, and if they don’t overlap they don’t need to be sorted!</p>
</li>
<li>
<p>Perform the actual blend/late Z/stencil operation. This is math – maybe a few dozen cycles worth, even with deeply pipelined units.</p>
</li>
<li>
<p>Write the results back to memory again, compressing etc. along the way – long latency again, though this time we’re not waiting for results so it’s less of a problem at this end.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We need to cover the long latencies somehow. And all this happens for every single pixel (well, quad, actually). So we need to worry about memory bandwidth too.</p>
</div>
</div>
<div class="sect3">
<h4 id="_memory_bandwidth_redux_dram_pages">Memory bandwidth redux: DRAM pages</h4>
<div class="paragraph">
<p>I described the 2D layout of DRAM, and how it’s faster to stay within a single row because changing the active row takes time – so for ideal bandwidth you want to stay in the same row between accesses. Well, the thing is, single DRAM rows are kinda large.</p>
</div>
<div class="paragraph">
<p>A DRAM page is some more conveniently sized slice of a row (by now, usually 256 or 512 bits) that’s commonly transferred in a single burst. Let’s take 512 bits (64 bytes) for now. At 32 bits per pixel that’s enough memory to fit data for 16 pixels in.</p>
</div>
<div class="paragraph">
<p>That gives us yet another reason to shade pixels in groups, and also yet another reason to do a two-level traversal. As soon as we’ve rasterized a tile, we know whether it generates any pixels or not. At that point, we can select a ROP to handle our quads for that tile, and queue a command to fetch the associated frame buffer data into a buffer. By the point we get shaded quads back from the shader units, that data should be there, and we can start blending without delay. Similarly for Z data – if we run early Z before the pixel shader, we might need to allocate a ROP and fetch depth/stencil data earlier, maybe as soon as a tile has passes the coarse Z test. If we run late Z, we can just prefetch the depth buffer data at the same time we grab the framebuffer pixels.</p>
</div>
<div class="paragraph">
<p>There’s also the issue of pixel shaders that output to multiple render targets, but that depends on how exactly that feature is implemented. You could run the shader multiple times, or you could run all the render targets through the same ROP, or you could allocate one ROP per output render target.</p>
</div>
</div>
<div class="sect3">
<h4 id="_depth_buffer_and_color_buffer_compression">Depth buffer and color buffer compression</h4>
<div class="paragraph">
<p>All the bandwidth issues I mentioned there exist for color values too; it’s not so bad for regular rendering, but it is a serious issue for MSAA, where we suddenly store somewhere between 2 and 8 samples per pixel. Like Z, we want some lossless compression scheme to save bandwidth in common cases. Unlike Z, plane equations per tile are not a good fit to textured pixel data.</p>
</div>
<div class="paragraph">
<p>MSAA pixel data is even easier to optimize for: pixel shaders only run once per pixel, not per sample. Hence, for all pixels that are fully covered by a single primitive, the 2-8 samples stored will usually be the same. And that’s the idea behind the common color buffer compression schemes: Write a flag bit (either per pixel, or per quad, or on an even larger granularity) that denotes whether for all the pixels in a compression block, all the per-sample colors are in fact the same. It requires some tag bits that we can store in a small on-chip SRAM. If there’s an edge crossing the pixels, we need the full bandwidth, but if the triangles aren’t too small, we can save a good deal of bandwidth on at least part of the frame. And again, we can use the same machinery to accelerate clears.</p>
</div>
<div class="paragraph">
<p><a id="fast_color_clear"></a>Some GPUs have “hierarchical Z”-like mechanisms that store, for a large block of pixels (a rasterizer tile, maybe even larger) that the block was recently cleared. Then you only need to store one color value for the whole tile (or larger block) in memory. This gives you very fast color clears for some buffers (again, you need some tag bits for this!). However, as soon as any pixel with non-clear color is written to the tile (or larger block), the “this was just cleared” flag needs to be… well, cleared. But we do save a lot of memory bandwidth on the clear itself and the first time a tile is read from memory.</p>
</div>
<div class="sect4">
<h5 id="_aside_why_no_fully_programmable_blend">Aside: Why no fully programmable blend?</h5>

</div>
</div>
<div class="sect3">
<h4 id="_1_blend_in_pixel_shader">1. Blend in Pixel Shader</h4>
<div class="paragraph">
<p>So why not just allow a read to the current render target? Turns out that unconstrained reads are a really bad idea, because it means that every pixel being shaded could (potentially) influence every other pixel being shaded. But what if we get a special render target read instruction that samples one of the active render targets at the current location? Now, that’s a lot better – now we only need to worry about writes to the location of the current quad, which is a way more tractable problem.</p>
</div>
<div class="paragraph">
<p>However, it still introduces ordering constraints; we have to check all quads generated by the rasterizer vs. the quads currently being pixel-shaded. If a quad just generated by the rasterizer wants to write to a sample that’ll be written by one of the Pixel Shaders that are currently in flight, we need to wait until that PS is completed before we can dispatch the new quad. This doesn’t sound too bad, but how do we track this?</p>
</div>
<div class="paragraph">
<p>This whole tracking thing is a problem. What if we just force shading to execute in order? That is, keep the whole thing pipelined and all shaders running in lockstep; now we don’t need tracking because pixels will finish in the same order we put them into the pipeline! But the problem here is that we need to make sure the shaders in a batch actually always take the exact same time.</p>
</div>
</div>
<div class="sect3">
<h4 id="_2_blend_shaders">2. “Blend Shaders”</h4>
<div class="paragraph">
<p>We now need another full ALU + instruction decoder/sequencer etc. in the ROPs. This is not a small change – not in design effort, nor in area, nor in power. Second, as I mentioned near the start of this post, our regular “just go wide” tactics don’t work so well for blend, because this is a place where we might well get a bunch of quads hitting the same pixels in a row and need to process them in order, so we want low latency. That’s a very different design point than our regular unified shader units – so we can’t use them for this. Third, pure serial execution is out at this point – too low throughput. So we need to pipeline it. But to pipeline it, we need to know how long the pipeline is! For a regular blend unit, it’s a fixed length, so it’s easy. A blend shader would probably be the same. In fact, due to the design constraints, you’re unlikely to get a blend shader – more like a blend register combiner, really, completely with a (presumably relatively low) upper limit on the number of instructions, as determined by the length of the pipeline.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_part_10_geometry_shaders">Part 10: Geometry Shaders.</h3>
<div class="paragraph">
<p><a href="https://fgiesen.wordpress.com/2011/07/20/a-trip-through-the-graphics-pipeline-2011-part-10/" class="bare">https://fgiesen.wordpress.com/2011/07/20/a-trip-through-the-graphics-pipeline-2011-part-10/</a></p>
</div>
<div class="sect3">
<h4 id="_theres_multiple_pipelines_anatomy_of_a_pipeline_stage">There’s multiple pipelines / anatomy of a pipeline stage</h4>
<div class="paragraph">
<p>For VS, we went through the Input Assembler, which prepared a block of vertices for shading, then dispatched that batch to a shader unit (which chews on it for a while), and then some time later we get the results back, write them into a buffer (for Primitive Assembly), make sure they’re in the right order, then send them down to the next pipeline stage (Culling/Clipping etc.).</p>
</div>
<div class="paragraph">
<p>For PS, we receive to-be-shaded quads from the rasterizer, batch them up, buffer them for a while until a shader unit is free to accept a new batch, dispatch a batch to a shader unit (which chews on it for a while), and then some time later we get the results back, write them into a buffer (for the ROPs), make sure they’re in the right order, then do blend/late Z and send the results on to memory.</p>
</div>
<div class="paragraph">
<p>In fact, this is how it always looks when we want to get something done by the shader units: we need a buffer in the front, then some dispatching logic (which is in fact pretty universal for all shader types and can be shared), then we go wide and run a bunch of shaders in parallel, and finally we need another buffer and a unit that sorts the results (which we received potentially out-of-order from the shader units) back into API order.</p>
</div>
<div class="paragraph">
<p>We’re not gonna see any big additions to shader unit functionality until we get to Compute Shaders, with their specialized buffer types and atomics. So for the next few parts, I won’t be talking about the shader units.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_shape_of_tris_to_shade">The Shape of Tris to Shade</h4>
<div class="paragraph">
<p>So let’s have a look at how our IO buffers for Geometry Shaders look. Let’s start with input. The Geometry Shader looks at primitives, not individual vertices, so what we really need is the output from Primitive Assembly (PA). PA could expand primitives out (duplicating vertices if they’re referenced multiple times), or it could just hand us one block of vertices with an associated small “index buffer”.</p>
</div>
<div class="paragraph">
<p>One reason you need to worry about amount of buffer space with GS is that it can work on some pretty large primitives, because it doesn’t just support plain lines or triangles, but also lines/triangles with adjacency information and patches with up to 32 control points as input.
Our input block is guaranteed to contain at least one full primitive, and possibly several – but other than that, the number of primitives in that block completely depends on the vertex cache hit rate.</p>
</div>
<div class="paragraph">
<p>With GS, we don’t have full control over either ends of the pipeline (since we’re in the middle!), and we need multiple input vertices per primitive (as opposed to multiple quads per one input triangle), so buffering up a lot of input is expensive (both in terms of memory and in the amount of management overhead we get).</p>
</div>
</div>
<div class="sect3">
<h4 id="_gs_output_no_rose_garden_over_here_either">GS output: no rose garden over here, either</h4>
<div class="paragraph">
<p>While a VS only outputs one thing (shaded vertices) with a 1:1 correspondence between unshaded and shaded vertices, a GS outputs a variable number of vertices (up to a maximum that’s specified at compile time), and as of D3D11 it can also have multiple output streams.</p>
</div>
<div class="paragraph">
<p>A GS produces variable-sized output, but it needs to run with bounded memory requirements, which is why the maximum number of output vertices is fixed at compile-time. This determines how much buffer space is allocated, and thus indirectly the maximum number of parallel GS invocations; if that number is too low, latency can’t be fully hidden, and the GS will stall for some percentage of the time.</p>
</div>
<div class="paragraph">
<p>Also note that the GS inputs <em>primitives</em> (e.g. points, lines, triangles or patches, optionally with adjacency information), but outputs <em>vertices</em> – even though we send primitives down to the rasterizer! If the output primitive type is points, this is trivial. For lines and triangles however, we need to reassemble those vertices back into primitives again.</p>
</div>
<div class="paragraph">
<p>So for GS, we need a second primitive assembly stage, which we’d like to keep simple, and assembling triangle strips is very simple indeed: a triangle is always 3 vertices from the output buffer in sequential order, with only a bit of glue logic to keep track of the current winding order.</p>
</div>
</div>
<div class="sect3">
<h4 id="_api_order_again">API order again</h4>
<div class="paragraph">
<p>For GS, we don’t generally know how many primitives we’re gonna generate before we get the outputs back – in fact, we might not have produced any! But we still need to respect API order: it’s first all primitives generated from GS invocation 0, then all primitives from invocation 1, and so on, through to the end of the batch (and of course the batches need to be processed in order too, same as with VS). So for GS, once we get results back, we first need to scan over the output data to determine the locations where complete primitives start. Only then can we start doing cull, clip and triangle setup (potentially in parallel).</p>
</div>
</div>
<div class="sect3">
<h4 id="_vpai_and_rtai">VPAI and RTAI</h4>
<div class="paragraph">
<p>The Render-target Array Index(RTAI) gives you render-to-texture-array support: you set a texture array as render target, and then in the GS you can select per-primitive to which array index the primitive should go. One example use case for RTAI is rendering cubemaps in one pass: the GS decides per primitive to which of the cube faces it should be sent (potentially several of them).</p>
</div>
<div class="paragraph">
<p>The Viewport Array Index (VPAI) is an orthogonal feature which allows you to set multiple viewports and scissor rects (up to 15), and then decide per primitive which viewport to use. This can be used, for example, to render multiple cascades in a Cascaded Shadow Map in a single pass.</p>
</div>
</div>
<div class="sect3">
<h4 id="_summary_so_far">Summary so far</h4>
<div class="paragraph">
<p>I checked it when D3D10 hardware was fairly new, and on both AMD and NVidia hardware, even a pure pass-through GS was between 3x and 7x slower than no GS at all (in a geometry-limited scenario, that is). I haven’t re-run this experiment on more recent hardware; I would assume that it’s gotten better by now (this was the first generation to implement GS, and features don’t usually have good performance in the first GPU generation that implements them), but the point still stands: just sending something through the GS pipe, even if nothing at all happens there, has a very visible cost.</p>
</div>
</div>
<div class="sect3">
<h4 id="_bonus_gs_instancing">Bonus: GS Instancing</h4>
<div class="paragraph">
<p>GS Instancing is another new feature of D3D11: for each input primitive, the GS gets run not just once but multiple times (this is a static count selected at compile time), by actually generating multiple GS invocations per input primitive, which helps us get larger batch sizes and thus better utilization.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_part_11_stream_out">Part 11: Stream-Out.</h3>
<div class="paragraph">
<p><a href="https://fgiesen.wordpress.com/2011/08/14/a-trip-through-the-graphics-pipeline-2011-part-11/" class="bare">https://fgiesen.wordpress.com/2011/08/14/a-trip-through-the-graphics-pipeline-2011-part-11/</a></p>
</div>
<div class="sect3">
<h4 id="_vertex_shader_stream_out_i_e_so_with_null_gs">Vertex Shader Stream-Out (i.e. SO with NULL GS)</h4>
<div class="paragraph">
<p>You simply pass Vertex Shader bytecode (instead of GS bytecode) to <code>CreateGeometryShaderWithStreamOutput</code>. What you get back is a Geometry Shader object that you can then pass to <code>GSSetShader</code>. This is, in effect, a NULL Geometry Shader – it doesn’t actually go through GS processing. It’s just some wrapper to make it fit into the API model, where all rendering passes through the GS stage and SO comes right after GS – though, actual HW tends to skip the GS stage completely when there’s no GS set.</p>
</div>
<div class="paragraph">
<p>So the shaded vertices get assembled into primitives as before, but instead of getting sent down the rest of the pipeline as already described, they get forwarded to Stream-Out, where they arrive – as always – in a buffer. In the Stream-Out declaration, the app gets to specify where it wants each output vector to end up in the Stream-Out targets .</p>
</div>
<div class="paragraph">
<p>SO usually doesn’t have access to a very high-performance path to the memory subsystem.</p>
</div>
<div class="paragraph">
<p>Primitive Assembly discards adjacency information if it makes it that far down the pipeline, and since this happens before SO, vertices corresponding to adjacency info won’t make it into SO buffers either. SO working on primitives not individual vertices is relevant for use cases like instancing a single skinned mesh (in a single pose) several times.</p>
</div>
</div>
<div class="sect3">
<h4 id="_geometry_shader_so_multiple_streams">Geometry Shader SO: Multiple streams</h4>
<div class="paragraph">
<p>Every GS can write to (as of D3D11) up to 4 streams. Each stream may be sent on to SO targets: a single stream can write to multiple SO targets, but a single SO target can receive values from only one stream.</p>
</div>
<div class="paragraph">
<p>The presence of streams has some implications for SO buffering – instead of a single input buffer like I described in the NULL GS case, we now may have multiple input buffers, one per stream.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tracking_output_size">Tracking output size</h4>
<div class="paragraph">
<p>We don’t necessarily know how much output data is going to be produced from SO. For GS, this comes about because each GS invocation may produce a variable number of output primitives; but even in the simpler VS case, as soon as indexed primitives are involved, the app might slip some “primitive cut” indices in there that influence how many primitives actually get written. This is a problem if we then want to draw from that SO buffer later, because we don’t know how many vertices are actually in there!</p>
</div>
<div class="paragraph">
<p>The GPU already knows how many valid vertices it actually wrote to the output buffer; the SO unit keeps track of that while it’s writing, and the final counter is also kept in memory (along with the buffer) since the app may render to a SO buffer in multiple passes. This counter is then used for <code>DrawAuto</code>, instead of having the app submit an explicit count itself – simplifying things considerably and avoiding the costly round-trip completely.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_part_12_tessellation">Part 12: Tessellation.</h3>
<div class="paragraph">
<p><a href="https://fgiesen.wordpress.com/2011/09/06/a-trip-through-the-graphics-pipeline-2011-part-12/" class="bare">https://fgiesen.wordpress.com/2011/09/06/a-trip-through-the-graphics-pipeline-2011-part-12/</a></p>
</div>
<div class="sect3">
<h4 id="_tessellation_not_quite_like_youd_expect">Tessellation – not quite like you’d expect</h4>
<div class="paragraph">
<p>The actual fixed-function tessellation unit deals only with the topology of the output mesh (i.e. how many vertices there are and how they’re connected to each other); and it turns out that from this perspective, there’s basically only two different types of patches: quad-based patches, which are defined on a parameter domain with two orthogonal coordinate axes (which I’ll call u and v here, both are in [0,1]) and usually constructed as a tensor product of two one-parameter basis functions, and triangle-based patches, which use a redundant representation with three coordinates (u, v, w) based on barycentric coordinates (i.e. \$u, v, w \ge 0, u + v + w = 1\$).</p>
</div>
</div>
<div class="sect3">
<h4 id="_making_ends_meet">Making ends meet</h4>
<div class="paragraph">
<p>Tessellating a single triangle (or quad) is easy, but we want to be able to determine tessellation factors per-patch, because we only want to spend triangles where we need them – and not waste tons of triangles on some distant (and possibly backface-culled) parts of the mesh.</p>
</div>
<div class="paragraph">
<p>The solution is to make all of the actual tessellation work purely local and push the burden of ensuring watertightness for the resulting mesh down to the shaders. This is a topic all by itself and requires <a href="http://www.ludicon.com/castano/blog/2010/09/precise/">great care in the Domain Shader code</a>.</p>
</div>
<div class="paragraph">
<p>The basic mechanism is that each patch has multiple tessellation factors (TFs), which are computed in the Hull Shader: one or two for the actual inside of the patch, plus one for each edge. The TFs for the inside of the patch can be chosen freely; but if two patches share an edge, they’d better compute the exact same TFs along that edge, or there will be cracks. The hardware doesn’t care – it will process each patch by itself. If you do everything correctly, you’ll get a nice watertight mesh.</p>
</div>
</div>
<div class="sect3">
<h4 id="_fractional_tessellation_factors_and_overall_pipeline_flow">Fractional tessellation factors and overall pipeline flow</h4>
<div class="paragraph">
<p>If the shader generates a non-integer TF, it will simply get rounded up to the next acceptable value. More interesting are the remaining two partitioning types: Fractional-odd and Fractional-even tessellation. Instead of jumping from tessellation factor to tessellation factor (which would cause visible pops), new vertices start out at the same position as an existing vertex in the mesh and then gradually move to their new positions as the TF increases.</p>
</div>
<div class="paragraph">
<p>The output of the tessellator then consists of two things: First, the positions of the tessellated vertices in domain coordinates, and second, the corresponding connectivity information – basically an index buffer.</p>
</div>
<div class="paragraph">
<p>Let’s see what we need to do to actually churn out primitives. First, we need to input a bunch of input control points comprising a patch into the Hull Shader. The HS then computes output control points and “patch constants” (both of which get passed down to the Domain Shader), plus all Tessellation Factors (which are essentially just more patch constants). Then we run the fixed-function tessellator, which gives us a bunch of Domain Positions to run the Domain Shader at, plus the associated indices. After we’ve run the DS, we then do another round of primitive assembly.</p>
</div>
</div>
<div class="sect3">
<h4 id="_hull_shader_execution">Hull Shader execution</h4>
<div class="paragraph">
<p>Unlike Geometry Shaders (which run for every primitive), Hull Shaders run once per patch, and as long as there’s any actual tessellation going on (even at modest TFs), we have way less patches than we have output triangles.</p>
</div>
<div class="paragraph">
<p>The other nice attribute of Hull Shaders is that, unlike Geometry Shaders, they don’t have a variable amount of output data; they produce a fixed amount of control points, each which a fixed amount of associated attributes, plus a fixed amount of patch constants. All of this is statically known at compile time; no dynamic run-time buffer management necessary.</p>
</div>
<div class="paragraph">
<p>Finally, Hull Shaders are somewhat special in the way they are compiled in D3D11; all other shader types basically consist of one block of code (with some subroutines maybe), but Hull Shaders are generated factored into multiple phases, each of which can consist of multiple (independent) threads of execution.</p>
</div>
<div class="paragraph">
<p>Hull Shaders produce a bunch of output per patch; most of it is just kept around until the corresponding Domain Shaders run, except for the TFs, which get sent to the tessellator unit. If any of the TFs are less than or equal to zero (or NaN), the patch is culled, and the corresponding control points and patch constants silently get thrown away.</p>
</div>
</div>
<div class="sect3">
<h4 id="_domain_shaders">Domain Shaders</h4>
<div class="paragraph">
<p>Domain Shaders are very simple indeed: the only input they get that actually varies per vertex is the domain point u and v coordinates. Everything else is either patch constants, control points (all of which are the same across a patch) or constant buffers. And output is basically the same as for Vertex Shaders.</p>
</div>
<div class="paragraph">
<p>This is perhaps the biggest advantage of the D3D11 tessellation pipeline over Geometry Shaders: the actual triangle amplification doesn’t happen in a shader, where we waste precious ALU cycles and need to keep buffer space for a worst-case estimate of vertices, but in a localized element (the tessellator) that is basically a state machine, gets very little input (a few TFs) and produces very compact output (effectively an index buffer, plus a 2D coordinate per output vertex).</p>
</div>
</div>
<div class="sect3">
<h4 id="_final_remarks_2">Final remarks</h4>
<div class="paragraph">
<p>The Tessellator has all kinds of symmetry and precision requirements; as far as vertex domain positions are concerned, you can basically expect bit-exact results between the different HW vendors, because the D3D11 spec really nails this bit down.</p>
</div>
<div class="paragraph">
<p>The tessellator will not produce adjacency information for the GS, just plain triangles.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_part_13_compute_shaders">Part 13: Compute Shaders.</h3>
<div class="paragraph">
<p><a href="https://fgiesen.wordpress.com/2011/10/09/a-trip-through-the-graphics-pipeline-2011-part-13/" class="bare">https://fgiesen.wordpress.com/2011/10/09/a-trip-through-the-graphics-pipeline-2011-part-13/</a></p>
</div>
<div class="sect3">
<h4 id="_execution_environment">Execution environment</h4>
<div class="paragraph">
<p>On the input side, there’s not really any buffers for input data at all. The only input Compute Shaders get, aside from API state such as the bound Constant Buffers and resources, is their thread index. There’s a tremendous potential for confusion here, so here’s the most important thing to keep in mind: a “thread” is the atomic unit of dispatch in the CS environment, and it’s a substantially different beast from the threads provided by the OS that you probably associate with the term. CS threads have their own identity and registers, but they don’t have their own Program Counter (Instruction Pointer) or stack, nor are they scheduled individually.</p>
</div>
<div class="paragraph">
<p><a id="cs_threads"></a>In fact, “threads” in CS take the place that individual vertices had during Vertex Shading, or individual pixels during Pixel Shading. And they get treated the same way: assemble a bunch of them (usually, somewhere between 16 and 64) into a “Warp” or “Wavefront” and let them run the same code in lockstep. CS threads don’t get scheduled – Warps and Wavefronts do. To hide latency, we don’t switch to a different “thread” (in CS parlance), but to a different Warp, i.e. a different bundle of threads. Single threads inside a Warp can’t take branches individually; if at least one thread in such a bundle wants to execute a certain piece of code, it gets processed by all the threads in the bundle – even if most threads then end up throwing the results away. In short, CS “threads” are more like SIMD lanes than like the threads you see elsewhere in programming.</p>
</div>
<div class="paragraph">
<p>Above that is the “thread group” level. The size of a thread group is specified during shader compilation. In DX11, a thread group can contain anywhere between 1 and 1024 threads, and the thread group size is specified not as a single number but as a 3-tuple giving thread x, y, and z coordinates. This numbering scheme is mostly for the convenience of shader code that addresses 2D or 3D resources.</p>
</div>
<div class="paragraph">
<p>Thread IDs – which can be passed in in various forms, depending on what the shader prefers – are the only input to Compute Shaders that’s not the same for all threads.</p>
</div>
</div>
<div class="sect3">
<h4 id="_thread_groups">Thread Groups</h4>
<div class="paragraph">
<p>There’s one important bit missing that makes thread groups very special indeed: Thread Group Shared Memory (TGSM). On DX11 level hardware, compute shaders have access to 32k of TGSM, which is basically a scratchpad for communication between threads in the same group.</p>
</div>
<div class="paragraph">
<p>In hardware all threads (well, Warps really) within a thread group get executed by the same shader unit. The shader unit then simply has at least 32k (usually a bit more) of local memory. And because all grouped threads share the same shader unit (and hence the same set of ALUs etc.), there’s no need to include complicated arbitration or synchronization mechanisms for shared memory access: only one Warp can access memory in any given cycle, because only one Warp gets to issue instructions in any cycle!</p>
</div>
<div class="paragraph">
<p>The above invariant guarantees that there’s only one set of accesses to TGSM per cycle even when we don’t add any interlocks to prevent concurrent access. This does not guarantee that memory accesses happen in any particular order from the perspective of the shader program, however, since Warps can be scheduled more or less randomly; it all depends on who is runnable at certain points in time. Because the whole process is pipelined, it might take some cycles for writes to TGSM to become “visible” to reads; this happens when the actual read and write operations to TGSM occur in different pipeline stages (or different phases of the same stage). So we still need some kind of synchronization mechanism. Enter barriers.</p>
</div>
<div class="paragraph">
<p><a id="barriers"></a>There’s different types of barriers:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>Group Synchronization</em>. A Group Synchronization Barrier forces all threads inside the current group to reach the barrier before any of them may consume past it. Once a Warp reaches such a barrier, it will be flagged as non-runnable, same as if it was waiting for a memory or texture access to complete. Once the last Warp reaches the barrier, the remaining Warps will be reactivated. This all happens at the Warp scheduling level; it adds additional scheduling constraints, which may cause stalls, but there’s no need for atomic memory transactions or anything like that; other than lost utilization at the micro level, this is a reasonably cheap operation.</p>
</li>
<li>
<p><em>Group Memory Barriers</em>. Since all threads within a group run on the same shader unit, this basically amounts to a pipeline flush, to ensure that all pending shared memory operations are completed. There’s no need to synchronize with resources external to the current shader unit, which means it’s again reasonably cheap.</p>
</li>
<li>
<p><em>Device Memory Barriers</em>. This blocks all threads within a group until all memory accesses have completed – either direct or indirect (e.g. via texture samples). As explained earlier in this series, memory accesses and texture samples on GPUs have long latencies – think more than 600, and often above 1000 cycles – so this kind of barrier will really hurt.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_unordered_access_views">Unordered Access Views</h4>
<div class="paragraph">
<p>Where do we put our output data? The answer has the unwieldy name “unordered access views”. An UAV seems somewhat similar to render targets in Pixel Shaders (and UAVs can in fact be used in addition to render targets in Pixel Shaders), but there’s some very important semantic differences:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Most importantly, as the same suggests, access to UAVs is “unordered”, in the sense that the API does not guarantee accesses to become visible in any particular order. When rendering primitives, quads are guaranteed to be Z-tested, blended and written back in API order, or at least produce the same results as if they were – which takes substantial effort. UAVs make no such effort – UAV accesses happen immediately as they’re encountered in the shader, which may be very different from API order. They’re not completely unordered, though; while there’s no guaranteed order of operations within an API call, the API and driver will still collaborate to make sure that perceived sequential ordering is preserved across API calls. Thus, if you have a complex Compute Shader (or Pixel Shader) writing to an UAV immediately followed by a second (simpler) CS that reads from the same underlying resource, the second CS will see the finished results, never some partially-written output.</p>
</li>
<li>
<p>UAVs support random access. A Pixel Shader can only write to one location per render target – its corresponding pixel. The same Pixel Shader can write to arbitrary locations in whatever UAVs it has bound.</p>
</li>
<li>
<p>UAVs support atomic operations. In the classic Pixel Pipeline, there’s no need; we guarantee there’s never any collisions anyway. But with the free-form execution provided by UAVs, different threads might be trying to access a piece of memory at the same time, and we need synchronization mechanisms to deal with this.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_atomics">Atomics</h4>
<div class="paragraph">
<p>In current CPUs, most of the magic for shared memory processing is handled by the memory hierarchy (i.e. caches). To write to a piece of memory, the active core must first assert exclusive ownership of the corresponding cache line. This is accomplished using what’s called a “cache coherency protocol”, usually <a href="http://en.wikipedia.org/wiki/MESI_protocol">MESI</a> and descendants.</p>
</div>
<div class="paragraph">
<p>In this type of model, atomic operations are performed using the regular Core ALUs and load/store units, and most of the “interesting” work happens in the caches. The advantage is that atomic operations are (more or less) regular memory accesses, albeit with some extra requirements. There’s a couple of problems, though: most importantly, the standard implementation of cache coherency, “snooping”, requires that all agents in the protocol talk to each other, which has serious scalability issues. Another issue is that all locks and memory transactions really happen at the cache line level; if two unrelated but frequently-updated variables share the same cache line, it can end up “ping-ponging” between multiple cores, causing tons of coherency transactions (and associated slowdown). This problem is called “false sharing”.</p>
</div>
<div class="paragraph">
<p>Current GPUs avoid this problem by structuring their memory hierarchy differently. Instead of handling atomic operations inside the shader units, there’s dedicated atomic units that directly talk to a shared lowest-level cache hierarchy. There’s only one such cache, so the issue of coherency doesn’t come up; either the cache line is present in the cache and it’s current or the copy in memory is current. Atomic operations consist of first bringing the respective memory location into the cache, then performing the required read-modify-write operation directly on the cache contents using a dedicated integer ALU on the atomic units. While an atomic unit is busy on a memory location, all other accesses to that location will stall. Since there’s multiple atomic units, it’s necessary to make sure they never try to access the same memory location at the same time.</p>
</div>
<div class="paragraph">
<p>If a shader unit wants to perform an atomic operation to a given memory address, it first needs to determine which atomic unit is responsible, wait until it is ready to accept new commands, and then submit the operation. The atomic unit might only be processing one command at a time, or it might have a small FIFO of outstanding requests.</p>
</div>
</div>
<div class="sect3">
<h4 id="_structured_buffers_and_appendconsume_buffers">Structured buffers and append/consume buffers</h4>
<div class="paragraph">
<p>Structured buffers are more of a hint to the driver-internal shader compiler than anything else; they give the driver some hint as to how they’re going to be used – namely, they consist of elements with a fixed stride that are likely going to be accessed together – but they still compile down to regular memory accesses in the end. The structured buffer part may bias the driver’s decision of their position and layout in memory, but it does not add any fundamentally new functionality to the model.</p>
</div>
<div class="paragraph">
<p>Append/consume buffers are similar; they could be implemented using the existing atomic instructions. In fact, they kind of are, except the append/consume pointers aren’t at an explicit location in the resource, they’re side-band data outside the resource that are accessed using special atomic instructions.</p>
</div>
<div class="sect4">
<h5 id="_wrap_up">Wrap-up.</h5>

</div>
</div>
</div>
</div>
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>